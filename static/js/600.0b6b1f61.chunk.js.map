{"version":3,"file":"static/js/600.0b6b1f61.chunk.js","mappings":"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","sources":["components/TetrisGame/TetrisGame.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\r\nimport './TetrisGame.css';\r\n\r\nconst TetrisGame = () => {\r\n  const canvasRef = useRef(null);\r\n  const [gameOver, setGameOver] = useState(false);\r\n  const [score, setScore] = useState(0);\r\n  const [topScore, setTopScore] = useState(0);\r\n  const gameStateRef = useRef({ isOver: false });\r\n\r\n  useEffect(() => {\r\n    const savedTopScore = localStorage.getItem('tetrisTopScore');\r\n    if (savedTopScore) setTopScore(parseInt(savedTopScore));\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas.getContext('2d');\r\n    const COLS = 10;\r\n    const ROWS = 20;\r\n    const BLOCK_SIZE = 30;\r\n    const COLORS = ['cyan', 'blue', 'orange', 'yellow', 'green', 'purple', 'red'];\r\n    const SHAPES = [\r\n      [[1, 1, 1, 1]],\r\n      [[1, 1, 1], [0, 1, 0]],\r\n      [[1, 1, 1], [1, 0, 0]],\r\n      [[1, 1, 1], [0, 0, 1]],\r\n      [[1, 1], [1, 1]],\r\n      [[1, 1, 0], [0, 1, 1]],\r\n      [[0, 1, 1], [1, 1, 0]],\r\n    ];\r\n\r\n    let board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));\r\n    let currentPiece = getRandomPiece();\r\n    let nextPiece = getRandomPiece();\r\n    let dropStart = Date.now();\r\n    let gameInterval;\r\n    let localScore = 0;\r\n\r\n    function getRandomPiece() {\r\n      const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];\r\n      const color = COLORS[Math.floor(Math.random() * COLORS.length)];\r\n      return { shape, color, x: Math.floor(COLS / 2) - 1, y: 0 };\r\n    }\r\n\r\n    function drawBoard() {\r\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n      for (let r = 0; r < ROWS; r++) {\r\n        for (let c = 0; c < COLS; c++) {\r\n          if (board[r][c]) {\r\n            ctx.fillStyle = board[r][c];\r\n            ctx.fillRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);\r\n            ctx.strokeRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    function drawPiece(piece) {\r\n      piece.shape.forEach((row, r) => {\r\n        row.forEach((cell, c) => {\r\n          if (cell) {\r\n            ctx.fillStyle = piece.color;\r\n            ctx.fillRect((piece.x + c) * BLOCK_SIZE, (piece.y + r) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);\r\n            ctx.strokeRect((piece.x + c) * BLOCK_SIZE, (piece.y + r) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);\r\n          }\r\n        });\r\n      });\r\n    }\r\n\r\n    function movePiece(piece, dx, dy) {\r\n      if (gameStateRef.current.isOver) return false;\r\n      piece.x += dx;\r\n      piece.y += dy;\r\n      if (collision(piece)) {\r\n        piece.x -= dx;\r\n        piece.y -= dy;\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n\r\n    function rotatePiece(piece) {\r\n      if (gameStateRef.current.isOver) return;\r\n      const originalShape = piece.shape.map(row => [...row]);\r\n      const originalX = piece.x;\r\n      const originalY = piece.y;\r\n\r\n      const rotated = piece.shape[0].map((_, index) =>\r\n        piece.shape.map(row => row[index]).reverse()\r\n      );\r\n\r\n      piece.shape = rotated;\r\n\r\n      const kicks = [\r\n        { x: 0, y: 0 },\r\n        { x: -1, y: 0 },\r\n        { x: 1, y: 0 },\r\n        { x: -2, y: 0 },\r\n        { x: 2, y: 0 },\r\n        { x: 0, y: -1 },\r\n        { x: 0, y: 1 }\r\n      ];\r\n\r\n      for (const kick of kicks) {\r\n        piece.x = originalX + kick.x;\r\n        piece.y = originalY + kick.y;\r\n        \r\n        if (!collision(piece)) {\r\n          return;\r\n        }\r\n      }\r\n\r\n      piece.shape = originalShape;\r\n      piece.x = originalX;\r\n      piece.y = originalY;\r\n    }\r\n\r\n    function collision(piece) {\r\n      return piece.shape.some((row, r) => {\r\n        return row.some((cell, c) => {\r\n          if (cell) {\r\n            const newX = piece.x + c;\r\n            const newY = piece.y + r;\r\n            return newX < 0 || newX >= COLS || newY >= ROWS || (newY >= 0 && board[newY][newX]);\r\n          }\r\n          return false;\r\n        });\r\n      });\r\n    }\r\n\r\n    function mergePiece(piece) {\r\n      piece.shape.forEach((row, r) => {\r\n        row.forEach((cell, c) => {\r\n          if (cell) {\r\n            board[piece.y + r][piece.x + c] = piece.color;\r\n          }\r\n        });\r\n      });\r\n    }\r\n\r\n    function clearLines() {\r\n      let clearedLines = 0;\r\n      board = board.filter(row => {\r\n        const isFull = row.every(cell => cell);\r\n        if (isFull) clearedLines++;\r\n        return !isFull;\r\n      });\r\n      \r\n      while (board.length < ROWS) {\r\n        board.unshift(Array(COLS).fill(0));\r\n      }\r\n\r\n      // Score calculation\r\n      if (clearedLines > 0) {\r\n        const scoreMultiplier = [0, 40, 100, 300, 1200];\r\n        localScore += scoreMultiplier[clearedLines] || 0;\r\n        setScore(localScore);\r\n\r\n        // Check for potential high score update\r\n        if (localScore > topScore) {\r\n          setTopScore(localScore);\r\n          localStorage.setItem('tetrisTopScore', localScore.toString());\r\n        }\r\n      }\r\n    }\r\n\r\n    function dropPiece() {\r\n      if (gameStateRef.current.isOver) return;\r\n      if (!movePiece(currentPiece, 0, 1)) {\r\n        mergePiece(currentPiece);\r\n        clearLines();\r\n        currentPiece = nextPiece;\r\n        nextPiece = getRandomPiece();\r\n        if (collision(currentPiece)) {\r\n          gameStateRef.current.isOver = true;\r\n          setGameOver(true);\r\n          if (localScore > topScore) {\r\n            setTopScore(localScore);\r\n            localStorage.setItem('tetrisTopScore', localScore.toString());\r\n          }\r\n          clearInterval(gameInterval);\r\n        }\r\n      }\r\n    }\r\n\r\n    function update() {\r\n      if (gameStateRef.current.isOver) return;\r\n      const now = Date.now();\r\n      const delta = now - dropStart;\r\n      if (delta > 1000) {\r\n        dropPiece();\r\n        dropStart = Date.now();\r\n      }\r\n      drawBoard();\r\n      drawPiece(currentPiece);\r\n    }\r\n\r\n    function handleKeyPress(e) {\r\n      if (gameStateRef.current.isOver) return;\r\n      switch (e.key) {\r\n        case 'ArrowLeft':\r\n          movePiece(currentPiece, -1, 0);\r\n          break;\r\n        case 'ArrowRight':\r\n          movePiece(currentPiece, 1, 0);\r\n          break;\r\n        case 'ArrowDown':\r\n          dropPiece();\r\n          break;\r\n        case 'ArrowUp':\r\n          rotatePiece(currentPiece);\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n\r\n    function handleTouch(e) {\r\n      if (gameStateRef.current.isOver) return;\r\n      \r\n      const rect = canvas.getBoundingClientRect();\r\n      const touch = e.touches[0];\r\n      const relX = touch.clientX - rect.left;\r\n      const relY = touch.clientY - rect.top;\r\n      \r\n      // Divide canvas into regions\r\n      const regionWidth = canvas.width / 3;\r\n      const regionHeight = canvas.height / 4;\r\n      \r\n      // Top region - rotate\r\n      if (relY < regionHeight) {\r\n        rotatePiece(currentPiece);\r\n      }\r\n      // Bottom region - drop\r\n      else if (relY > canvas.height - regionHeight) {\r\n        dropPiece();\r\n      }\r\n      // Left region - move left\r\n      else if (relX < regionWidth) {\r\n        movePiece(currentPiece, -1, 0);\r\n      }\r\n      // Right region - move right\r\n      else if (relX > regionWidth * 2) {\r\n        movePiece(currentPiece, 1, 0);\r\n      }\r\n      \r\n      e.preventDefault();\r\n    }\r\n\r\n    window.addEventListener('keydown', handleKeyPress);\r\n    canvas.addEventListener('touchstart', handleTouch);\r\n    gameInterval = setInterval(update, 50);\r\n\r\n    return () => {\r\n      window.removeEventListener('keydown', handleKeyPress);\r\n      canvas.removeEventListener('touchstart', handleTouch);\r\n      clearInterval(gameInterval);\r\n      gameStateRef.current.isOver = false;\r\n    };\r\n  }, [gameOver, score, topScore]);\r\n\r\n  const resetGame = () => {\r\n    setGameOver(false);\r\n    setScore(0);\r\n    gameStateRef.current.isOver = false;\r\n  };\r\n\r\n  return (\r\n    <div className=\"tetris-game-container\">\r\n      <div className=\"scoreboard\">\r\n        <div>Score: {score}</div>\r\n        <div>Top Score: {topScore}</div>\r\n      </div>\r\n      <canvas \r\n        ref={canvasRef} \r\n        width=\"300\" \r\n        height=\"600\" \r\n        className=\"tetris-game-canvas\"\r\n      />\r\n      {gameOver && <div className=\"game-over\">Game Over</div>}\r\n      <button onClick={resetGame}>Restart</button>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default TetrisGame;"],"names":["TetrisGame","canvasRef","useRef","gameOver","setGameOver","useState","score","setScore","topScore","setTopScore","gameStateRef","isOver","useEffect","savedTopScore","localStorage","getItem","parseInt","canvas","current","ctx","getContext","BLOCK_SIZE","COLORS","SHAPES","gameInterval","board","Array","from","length","fill","currentPiece","getRandomPiece","nextPiece","dropStart","Date","now","localScore","shape","Math","floor","random","color","x","COLS","y","movePiece","piece","dx","dy","collision","rotatePiece","originalShape","map","row","originalX","originalY","rotated","_","index","reverse","kicks","kick","some","r","cell","c","newX","newY","dropPiece","forEach","clearedLines","filter","isFull","every","unshift","setItem","toString","clearLines","clearInterval","handleKeyPress","e","key","handleTouch","rect","getBoundingClientRect","touch","touches","relX","clientX","left","relY","clientY","top","regionWidth","width","regionHeight","height","preventDefault","window","addEventListener","setInterval","clearRect","fillStyle","fillRect","strokeRect","drawBoard","removeEventListener","_jsxs","className","children","_jsx","ref","onClick","resetGame"],"sourceRoot":""}