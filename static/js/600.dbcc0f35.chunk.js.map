{"version":3,"file":"static/js/600.dbcc0f35.chunk.js","mappings":"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","sources":["components/TetrisGame/TetrisGame.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\nimport './TetrisGame.css';\n\nconst TetrisGame = () => {\n  const canvasRef = useRef(null);\n  const [gameOver, setGameOver] = useState(false);\n  const [score, setScore] = useState(0);\n  const [topScore, setTopScore] = useState(0);\n  const gameStateRef = useRef({ isOver: false });\n\n  useEffect(() => {\n    const savedTopScore = localStorage.getItem('tetrisTopScore');\n    if (savedTopScore) setTopScore(parseInt(savedTopScore));\n  }, []);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const COLS = 10;\n    const ROWS = 20;\n    const BLOCK_SIZE = 30;\n    const COLORS = ['#5abb9a', '#ffebcd', '#d4b99c', '#7fffd4', '#bae1ff', '#baffc9', '#ffb3ba'];\n    const SHAPES = [\n      [[1, 1, 1, 1]],\n      [[1, 1, 1], [0, 1, 0]],\n      [[1, 1, 1], [1, 0, 0]],\n      [[1, 1, 1], [0, 0, 1]],\n      [[1, 1], [1, 1]],\n      [[1, 1, 0], [0, 1, 1]],\n      [[0, 1, 1], [1, 1, 0]],\n    ];\n\n    let board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));\n    let currentPiece = getRandomPiece();\n    let nextPiece = getRandomPiece();\n    let dropStart = Date.now();\n    let gameInterval;\n    let localScore = 0;\n\n    function getRandomPiece() {\n      const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];\n      const color = COLORS[Math.floor(Math.random() * COLORS.length)];\n      return { shape, color, x: Math.floor(COLS / 2) - 1, y: 0 };\n    }\n\n    function drawBoard() {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      for (let r = 0; r < ROWS; r++) {\n        for (let c = 0; c < COLS; c++) {\n          if (board[r][c]) {\n            ctx.fillStyle = board[r][c];\n            ctx.fillRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);\n            ctx.strokeRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);\n          }\n        }\n      }\n    }\n\n    function drawPiece(piece) {\n      piece.shape.forEach((row, r) => {\n        row.forEach((cell, c) => {\n          if (cell) {\n            ctx.fillStyle = piece.color;\n            ctx.fillRect((piece.x + c) * BLOCK_SIZE, (piece.y + r) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);\n            ctx.strokeRect((piece.x + c) * BLOCK_SIZE, (piece.y + r) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);\n          }\n        });\n      });\n    }\n\n    function movePiece(piece, dx, dy) {\n      if (gameStateRef.current.isOver) return false;\n      piece.x += dx;\n      piece.y += dy;\n      if (collision(piece)) {\n        piece.x -= dx;\n        piece.y -= dy;\n        return false;\n      }\n      return true;\n    }\n\n    function rotatePiece(piece) {\n      if (gameStateRef.current.isOver) return;\n      const originalShape = piece.shape.map(row => [...row]);\n      const originalX = piece.x;\n      const originalY = piece.y;\n\n      const rotated = piece.shape[0].map((_, index) =>\n        piece.shape.map(row => row[index]).reverse()\n      );\n\n      piece.shape = rotated;\n\n      const kicks = [\n        { x: 0, y: 0 },\n        { x: -1, y: 0 },\n        { x: 1, y: 0 },\n        { x: -2, y: 0 },\n        { x: 2, y: 0 },\n        { x: 0, y: -1 },\n        { x: 0, y: 1 }\n      ];\n\n      for (const kick of kicks) {\n        piece.x = originalX + kick.x;\n        piece.y = originalY + kick.y;\n        \n        if (!collision(piece)) {\n          return;\n        }\n      }\n\n      piece.shape = originalShape;\n      piece.x = originalX;\n      piece.y = originalY;\n    }\n\n    function collision(piece) {\n      return piece.shape.some((row, r) => {\n        return row.some((cell, c) => {\n          if (cell) {\n            const newX = piece.x + c;\n            const newY = piece.y + r;\n            return newX < 0 || newX >= COLS || newY >= ROWS || (newY >= 0 && board[newY][newX]);\n          }\n          return false;\n        });\n      });\n    }\n\n    function mergePiece(piece) {\n      piece.shape.forEach((row, r) => {\n        row.forEach((cell, c) => {\n          if (cell) {\n            board[piece.y + r][piece.x + c] = piece.color;\n          }\n        });\n      });\n    }\n\n    function clearLines() {\n      let clearedLines = 0;\n      board = board.filter(row => {\n        const isFull = row.every(cell => cell);\n        if (isFull) clearedLines++;\n        return !isFull;\n      });\n      \n      while (board.length < ROWS) {\n        board.unshift(Array(COLS).fill(0));\n      }\n\n      // Score calculation\n      if (clearedLines > 0) {\n        const scoreMultiplier = [0, 40, 100, 300, 1200];\n        localScore += scoreMultiplier[clearedLines] || 0;\n        setScore(localScore);\n\n        // Check for potential high score update\n        if (localScore > topScore) {\n          setTopScore(localScore);\n          localStorage.setItem('tetrisTopScore', localScore.toString());\n        }\n      }\n    }\n\n    function dropPiece() {\n      if (gameStateRef.current.isOver) return;\n      if (!movePiece(currentPiece, 0, 1)) {\n        mergePiece(currentPiece);\n        clearLines();\n        currentPiece = nextPiece;\n        nextPiece = getRandomPiece();\n        if (collision(currentPiece)) {\n          gameStateRef.current.isOver = true;\n          setGameOver(true);\n          if (localScore > topScore) {\n            setTopScore(localScore);\n            localStorage.setItem('tetrisTopScore', localScore.toString());\n          }\n          clearInterval(gameInterval);\n        }\n      }\n    }\n\n    function update() {\n      if (gameStateRef.current.isOver) return;\n      const now = Date.now();\n      const delta = now - dropStart;\n      if (delta > 1000) {\n        dropPiece();\n        dropStart = Date.now();\n      }\n      drawBoard();\n      drawPiece(currentPiece);\n    }\n\n    function handleKeyPress(e) {\n      if (gameStateRef.current.isOver) return;\n      switch (e.key) {\n        case 'ArrowLeft':\n          movePiece(currentPiece, -1, 0);\n          e.preventDefault();\n          break;\n        case 'ArrowRight':\n          movePiece(currentPiece, 1, 0);\n          e.preventDefault();\n          break;\n        case 'ArrowDown':\n          dropPiece();\n          e.preventDefault();\n          break;\n        case 'ArrowUp':\n          rotatePiece(currentPiece);\n          e.preventDefault();\n          break;\n        default:\n          break;\n      }\n    }\n\n    function handleTouch(e) {\n      if (gameStateRef.current.isOver) return;\n      \n      const rect = canvas.getBoundingClientRect();\n      const touch = e.touches[0];\n      const relX = touch.clientX - rect.left;\n      const relY = touch.clientY - rect.top;\n      \n      // Divide canvas into regions\n      const regionWidth = canvas.width / 3;\n      const regionHeight = canvas.height / 4;\n      \n      // Top region - rotate\n      if (relY < regionHeight) {\n        rotatePiece(currentPiece);\n      }\n      // Bottom region - drop\n      else if (relY > canvas.height - regionHeight) {\n        dropPiece();\n      }\n      // Left region - move left\n      else if (relX < regionWidth) {\n        movePiece(currentPiece, -1, 0);\n      }\n      // Right region - move right\n      else if (relX > regionWidth * 2) {\n        movePiece(currentPiece, 1, 0);\n      }\n      \n      e.preventDefault();\n    }\n\n    window.addEventListener('keydown', handleKeyPress);\n    canvas.addEventListener('touchstart', handleTouch);\n    gameInterval = setInterval(update, 50);\n\n    const currentGameState = gameStateRef.current;\n\n    return () => {\n      window.removeEventListener('keydown', handleKeyPress);\n      canvas.removeEventListener('touchstart', handleTouch);\n      clearInterval(gameInterval);\n      currentGameState.isOver = false;\n    };\n  }, [gameOver, score, topScore]);\n\n  const resetGame = () => {\n    setGameOver(false);\n    setScore(0);\n    gameStateRef.current.isOver = false;\n  };\n\n  return (\n    <div className=\"tetris-game-container\">\n      <div className=\"scoreboard\">\n        <div>Score: {score}</div>\n        <div>Top Score: {topScore}</div>\n      </div>\n      <canvas\n        ref={canvasRef}\n        width=\"300\"\n        height=\"600\"\n        className=\"tetris-game-canvas\"\n      />\n      {gameOver && <div className=\"game-over\">Game Over! Score: {score}</div>}\n      <button className=\"restart-button\" onClick={resetGame}>Restart</button>\n    </div>\n  );\n};\n\nexport default TetrisGame;"],"names":["TetrisGame","canvasRef","useRef","gameOver","setGameOver","useState","score","setScore","topScore","setTopScore","gameStateRef","isOver","useEffect","savedTopScore","localStorage","getItem","parseInt","canvas","current","ctx","getContext","BLOCK_SIZE","COLORS","SHAPES","gameInterval","board","Array","from","length","fill","currentPiece","getRandomPiece","nextPiece","dropStart","Date","now","localScore","shape","Math","floor","random","color","x","COLS","y","movePiece","piece","dx","dy","collision","rotatePiece","originalShape","map","row","originalX","originalY","rotated","_","index","reverse","kicks","kick","some","r","cell","c","newX","newY","dropPiece","forEach","clearedLines","filter","isFull","every","unshift","setItem","toString","clearLines","clearInterval","handleKeyPress","e","key","preventDefault","handleTouch","rect","getBoundingClientRect","touch","touches","relX","clientX","left","relY","clientY","top","regionWidth","width","regionHeight","height","window","addEventListener","setInterval","clearRect","fillStyle","fillRect","strokeRect","drawBoard","currentGameState","removeEventListener","_jsxs","className","children","_jsx","ref","onClick","resetGame"],"sourceRoot":""}