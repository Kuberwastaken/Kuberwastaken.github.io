{"version":3,"file":"static/js/529.f48a162d.chunk.js","mappings":"mKAGA,MAGMA,EAAiBA,KACrB,MAAMC,EAAOC,MAJF,GAIcC,KAAK,MAAMC,KAAI,IAAMF,MAJnC,GAI+CC,KAAK,KAG/D,OAFAE,EAAcJ,GACdI,EAAcJ,GACPA,CAAI,EAGPI,EAAiBJ,IACrB,MAAMK,EAAa,GACnB,IAAK,IAAIC,EAAI,EAAGA,EAZL,EAYeA,IACxB,IAAK,IAAIC,EAAI,EAAGA,EAbP,EAaiBA,IACL,IAAfP,EAAKM,GAAGC,IACVF,EAAWG,KAAK,CAAEF,IAAGC,MAI3B,GAAIF,EAAWI,OAAS,EAAG,CACzB,MAAM,EAAEH,EAAC,EAAEC,GAAMF,EAAWK,KAAKC,MAAMD,KAAKE,SAAWP,EAAWI,SAClET,EAAKM,GAAGC,GAAKG,KAAKE,SAAW,GAAM,EAAI,CACzC,GAGIC,EAAYb,IAChB,IAAIc,EAAQ,EACRC,GAAQ,EAmBZ,MAAO,CAAEf,KAlBOA,EAAKG,KAAIa,IACvB,MAAMC,EAAWD,EAAIE,QAAOC,GAAiB,IAATA,IACpC,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAASR,OAAS,EAAGW,IACnCH,EAASG,KAAOH,EAASG,EAAI,KAC/BH,EAASG,IAAM,EACfN,GAASG,EAASG,GAClBH,EAASI,OAAOD,EAAI,EAAG,GACvBL,GAAQ,GAGZ,KAAOE,EAASR,OAtCP,GAuCPQ,EAAST,KAAK,GAKhB,OAHIS,EAASK,MAAK,CAACC,EAAKC,IAAQD,IAAQP,EAAIQ,OAC1CT,GAAQ,GAEHE,CAAQ,IAEOF,QAAOD,QAAO,EAGlCW,EAAczB,IAClB,MAAM0B,EAAUzB,MAlDL,GAkDiBC,OAAOC,KAAI,IAAMF,MAlDlC,GAkD8CC,KAAK,KAC9D,IAAK,IAAII,EAAI,EAAGA,EAnDL,EAmDeA,IACxB,IAAK,IAAIC,EAAI,EAAGA,EApDP,EAoDiBA,IACxBmB,EAAQnB,GAAGoB,EAAWrB,GAAKN,EAAKM,GAAGC,GAGvC,OAAOmB,CAAO,EA0DVE,EAAWA,KACf,MAAO5B,EAAM6B,IAAWC,EAAAA,EAAAA,UAAS/B,MAC1Be,EAAOiB,IAAYD,EAAAA,EAAAA,UAAS,IAC5BE,EAAUC,IAAeH,EAAAA,EAAAA,UAAS,IAClCI,EAAUC,IAAeL,EAAAA,EAAAA,WAAS,IAClCM,EAAYC,IAAiBP,EAAAA,EAAAA,UAAS,MAEvCQ,EAAcC,IAClB,GAAIL,EAAU,OACd,MAAQlC,KAAM0B,EAAO,MAAEX,EAAOD,MAAO0B,GAhExBC,EAACzC,EAAMuC,KACtB,IAAIb,EAAU1B,EAAKG,KAAIa,GAAO,IAAIA,KAC9BD,GAAQ,EACRD,EAAQ,EACZ,OAAQyB,GACN,IAAK,QACHb,EAAUD,EAAWA,EAAWC,IAChC,MAAMgB,EAAc7B,EAASa,GAC7BA,EAAUD,EAAWA,EAAWiB,EAAY1C,OAC5Ce,EAAQ2B,EAAY3B,MACpBD,EAAQ4B,EAAY5B,MACpB,MACF,IAAK,KACHY,EAAUD,EAAWA,EAAWA,EAAWC,KAC3C,MAAMiB,EAAW9B,EAASa,GAC1BA,EAAUD,EAAWkB,EAAS3C,MAC9Be,EAAQ4B,EAAS5B,MACjBD,EAAQ6B,EAAS7B,MACjB,MACF,IAAK,OACHY,EAAUD,EAAWC,GACrB,MAAMkB,EAAa/B,EAASa,GAC5BA,EAAUD,EAAWA,EAAWA,EAAWmB,EAAW5C,QACtDe,EAAQ6B,EAAW7B,MACnBD,EAAQ8B,EAAW9B,MACnB,MACF,IAAK,OACH,MAAM+B,EAAahC,EAASa,GAC5BA,EAAUmB,EAAW7C,KACrBe,EAAQ8B,EAAW9B,MACnBD,EAAQ+B,EAAW/B,MAGvB,MAAO,CAAEd,KAAM0B,EAASX,QAAOD,QAAO,EA+Bc2B,CAAS,IAAIzC,GAAOuC,GAClExB,IACFX,EAAcsB,GACdG,EAAQH,GACRK,EAASjB,EAAQ0B,GACb1B,EAAQ0B,EAAWR,GACrBC,EAAYnB,EAAQ0B,GAlCLxC,KACrB,IAAK,IAAIM,EAAI,EAAGA,EAhGL,EAgGeA,IACxB,IAAK,IAAIC,EAAI,EAAGA,EAjGP,EAiGiBA,IACxB,GAAmB,IAAfP,EAAKM,GAAGC,GAAU,OAAO,EAGjC,IAAK,IAAID,EAAI,EAAGA,EArGL,EAqGeA,IACxB,IAAK,IAAIC,EAAI,EAAGA,EAtGP,EAsGiBA,IACxB,GACGD,EAAIqB,GAAY3B,EAAKM,GAAGC,KAAOP,EAAKM,EAAI,GAAGC,IAC3CA,EAAIoB,GAAY3B,EAAKM,GAAGC,KAAOP,EAAKM,GAAGC,EAAI,GAE5C,OAAO,EAIb,OAAO,CAAI,EAoBHuC,CAAcpB,IAChBS,GAAY,GAEhB,EASIY,EAAiBC,IACrB,GAAIA,EAAEC,IAAIC,WAAW,SAAU,CAC7BF,EAAEG,iBAOFb,EANmB,CACjBc,UAAW,OACXC,WAAY,QACZC,QAAS,KACTC,UAAW,QAESP,EAAEC,KAC1B,GAyCF,OALAO,EAAAA,EAAAA,YAAU,KACRC,OAAOC,iBAAiB,UAAWX,GAC5B,IAAMU,OAAOE,oBAAoB,UAAWZ,KAClD,CAAC/C,EAAMkC,KAGR0B,EAAAA,EAAAA,MAAA,OACEC,UAAU,sBACVC,aAzCsBd,IACxBA,EAAEG,iBACF,MAAMY,EAAQf,EAAEgB,QAAQ,GACxB3B,EAAc,CACZ4B,EAAGF,EAAMG,QACTC,EAAGJ,EAAMK,SACT,EAoCAC,YAjCqBrB,IACvBA,EAAEG,gBAAgB,EAiChBmB,WA9BoBtB,IAEtB,GADAA,EAAEG,kBACGf,EAAY,OAEjB,MAAM2B,EAAQf,EAAEuB,eAAe,GACzBC,EAAKT,EAAMG,QAAU9B,EAAW6B,EAChCQ,EAAKV,EAAMK,QAAUhC,EAAW+B,EAClCzD,KAAKgE,IAAIF,GA/KO,IA+KkB9D,KAAKgE,IAAID,GA/K3B,KAoLhB/D,KAAKgE,IAAIF,GAAM9D,KAAKgE,IAAID,GAC1BnC,EAAWkC,EAAK,EAAI,QAAU,QAE9BlC,EAAWmC,EAAK,EAAI,OAAS,OAP7BpC,EAAc,KASG,EAaUsC,SAAA,EAE3Bf,EAAAA,EAAAA,MAAA,OAAKC,UAAU,aAAYc,SAAA,EACzBf,EAAAA,EAAAA,MAAA,OAAAe,SAAA,CAAK,UAAQ7D,MACb8C,EAAAA,EAAAA,MAAA,OAAAe,SAAA,CAAK,cAAY3C,SAEnB4C,EAAAA,EAAAA,KAAA,OAAKf,UAAU,iBAAgBc,SAC5B3E,EAAKG,KAAI,CAACa,EAAK6D,IACd7D,EAAIb,KAAI,CAACgB,EAAM2D,KACbF,EAAAA,EAAAA,KAAA,OAA6Bf,UAAS,wBAAAkB,OAA0B5D,GAAOwD,UACrEC,EAAAA,EAAAA,KAAA,OAAAD,SAAe,IAATxD,GAAcA,KAAW,GAAA4D,OADpBF,EAAI,KAAAE,OAAID,UAM1B5C,IAAY0C,EAAAA,EAAAA,KAAA,OAAKf,UAAU,YAAWc,SAAC,eACxCC,EAAAA,EAAAA,KAAA,UAAQI,QA9EMC,KAChBpD,EAAQ9B,KACRgC,EAAS,GACTI,GAAY,EAAM,EA2EWwC,SAAC,cACxB,EAIV,EAAeO,EAAAA,KAAWtD,E","sources":["components/Game2048/Game2048.js"],"sourcesContent":["import React, { useEffect, useState } from 'react';\r\nimport './Game2048.css';\r\n\r\nconst SIZE = 4;\r\nconst SWIPE_THRESHOLD = 50;\r\n\r\nconst getInitialGrid = () => {\r\n  const grid = Array(SIZE).fill(null).map(() => Array(SIZE).fill(0));\r\n  addRandomTile(grid);\r\n  addRandomTile(grid);\r\n  return grid;\r\n};\r\n\r\nconst addRandomTile = (grid) => {\r\n  const emptyTiles = [];\r\n  for (let r = 0; r < SIZE; r++) {\r\n    for (let c = 0; c < SIZE; c++) {\r\n      if (grid[r][c] === 0) {\r\n        emptyTiles.push({ r, c });\r\n      }\r\n    }\r\n  }\r\n  if (emptyTiles.length > 0) {\r\n    const { r, c } = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];\r\n    grid[r][c] = Math.random() < 0.9 ? 2 : 4;\r\n  }\r\n};\r\n\r\nconst moveLeft = (grid) => {\r\n  let score = 0;\r\n  let moved = false;\r\n  const newGrid = grid.map(row => {\r\n    const filtered = row.filter(cell => cell !== 0);\r\n    for (let i = 0; i < filtered.length - 1; i++) {\r\n      if (filtered[i] === filtered[i + 1]) {\r\n        filtered[i] *= 2;\r\n        score += filtered[i];\r\n        filtered.splice(i + 1, 1);\r\n        moved = true;\r\n      }\r\n    }\r\n    while (filtered.length < SIZE) {\r\n      filtered.push(0);\r\n    }\r\n    if (filtered.some((val, idx) => val !== row[idx])) {\r\n      moved = true;\r\n    }\r\n    return filtered;\r\n  });\r\n  return { grid: newGrid, moved, score };\r\n};\r\n\r\nconst rotateGrid = (grid) => {\r\n  const newGrid = Array(SIZE).fill().map(() => Array(SIZE).fill(0));\r\n  for (let r = 0; r < SIZE; r++) {\r\n    for (let c = 0; c < SIZE; c++) {\r\n      newGrid[c][SIZE - 1 - r] = grid[r][c];\r\n    }\r\n  }\r\n  return newGrid;\r\n};\r\n\r\nconst moveGrid = (grid, direction) => {\r\n  let newGrid = grid.map(row => [...row]);\r\n  let moved = false;\r\n  let score = 0;\r\n  switch (direction) {\r\n    case 'right':\r\n      newGrid = rotateGrid(rotateGrid(newGrid));\r\n      const rightResult = moveLeft(newGrid);\r\n      newGrid = rotateGrid(rotateGrid(rightResult.grid));\r\n      moved = rightResult.moved;\r\n      score = rightResult.score;\r\n      break;\r\n    case 'up':\r\n      newGrid = rotateGrid(rotateGrid(rotateGrid(newGrid)));\r\n      const upResult = moveLeft(newGrid);\r\n      newGrid = rotateGrid(upResult.grid);\r\n      moved = upResult.moved;\r\n      score = upResult.score;\r\n      break;\r\n    case 'down':\r\n      newGrid = rotateGrid(newGrid);\r\n      const downResult = moveLeft(newGrid);\r\n      newGrid = rotateGrid(rotateGrid(rotateGrid(downResult.grid)));\r\n      moved = downResult.moved;\r\n      score = downResult.score;\r\n      break;\r\n    case 'left':\r\n      const leftResult = moveLeft(newGrid);\r\n      newGrid = leftResult.grid;\r\n      moved = leftResult.moved;\r\n      score = leftResult.score;\r\n      break;\r\n  }\r\n  return { grid: newGrid, moved, score };\r\n};\r\n\r\nconst checkGameOver = (grid) => {\r\n  for (let r = 0; r < SIZE; r++) {\r\n    for (let c = 0; c < SIZE; c++) {\r\n      if (grid[r][c] === 0) return false;\r\n    }\r\n  }\r\n  for (let r = 0; r < SIZE; r++) {\r\n    for (let c = 0; c < SIZE; c++) {\r\n      if (\r\n        (r < SIZE - 1 && grid[r][c] === grid[r + 1][c]) ||\r\n        (c < SIZE - 1 && grid[r][c] === grid[r][c + 1])\r\n      ) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n  return true;\r\n};\r\n\r\nconst Game2048 = () => {\r\n  const [grid, setGrid] = useState(getInitialGrid());\r\n  const [score, setScore] = useState(0);\r\n  const [topScore, setTopScore] = useState(0);\r\n  const [gameOver, setGameOver] = useState(false);\r\n  const [touchStart, setTouchStart] = useState(null);\r\n\r\n  const handleMove = (direction) => {\r\n    if (gameOver) return;\r\n    const { grid: newGrid, moved, score: newScore } = moveGrid([...grid], direction);\r\n    if (moved) {\r\n      addRandomTile(newGrid);\r\n      setGrid(newGrid);\r\n      setScore(score + newScore);\r\n      if (score + newScore > topScore) {\r\n        setTopScore(score + newScore);\r\n      }\r\n      if (checkGameOver(newGrid)) {\r\n        setGameOver(true);\r\n      }\r\n    }\r\n  };\r\n\r\n  const resetGame = () => {\r\n    setGrid(getInitialGrid());\r\n    setScore(0);\r\n    setGameOver(false);\r\n  };\r\n\r\n  const handleKeyDown = (e) => {\r\n    if (e.key.startsWith('Arrow')) {\r\n      e.preventDefault();\r\n      const directions = {\r\n        ArrowLeft: 'left',\r\n        ArrowRight: 'right',\r\n        ArrowUp: 'up',\r\n        ArrowDown: 'down'\r\n      };\r\n      handleMove(directions[e.key]);\r\n    }\r\n  };\r\n\r\n  const handleTouchStart = (e) => {\r\n    e.preventDefault();\r\n    const touch = e.touches[0];\r\n    setTouchStart({\r\n      x: touch.clientX,\r\n      y: touch.clientY\r\n    });\r\n  };\r\n\r\n  const handleTouchMove = (e) => {\r\n    e.preventDefault(); // Prevent scrolling while swiping\r\n  };\r\n\r\n  const handleTouchEnd = (e) => {\r\n    e.preventDefault(); // Yes somehow defining it TWICE makes it work\r\n    if (!touchStart) return;\r\n    \r\n    const touch = e.changedTouches[0];\r\n    const dx = touch.clientX - touchStart.x;\r\n    const dy = touch.clientY - touchStart.y;\r\n    if (Math.abs(dx) < SWIPE_THRESHOLD && Math.abs(dy) < SWIPE_THRESHOLD) {\r\n      setTouchStart(null);\r\n      return;\r\n    }\r\n    \r\n    if (Math.abs(dx) > Math.abs(dy)) {\r\n      handleMove(dx > 0 ? 'right' : 'left');\r\n    } else {\r\n      handleMove(dy > 0 ? 'down' : 'up');\r\n    }\r\n    setTouchStart(null);\r\n  };\r\n\r\n  useEffect(() => {\r\n    window.addEventListener('keydown', handleKeyDown);\r\n    return () => window.removeEventListener('keydown', handleKeyDown);\r\n  }, [grid, gameOver]);\r\n\r\n  return (\r\n    <div \r\n      className=\"game-2048-container\"\r\n      onTouchStart={handleTouchStart}\r\n      onTouchMove={handleTouchMove}\r\n      onTouchEnd={handleTouchEnd}\r\n    >\r\n      <div className=\"scoreboard\">\r\n        <div>Score: {score}</div>\r\n        <div>Top Score: {topScore}</div>\r\n      </div>\r\n      <div className=\"game-2048-grid\">\r\n        {grid.map((row, rIdx) =>\r\n          row.map((cell, cIdx) => (\r\n            <div key={`${rIdx}-${cIdx}`} className={`game-2048-cell value-${cell}`}>\r\n              <div>{cell !== 0 && cell}</div>\r\n            </div>\r\n          ))\r\n        )}\r\n      </div>\r\n      {gameOver && <div className=\"game-over\">Game Over</div>}\r\n      <button onClick={resetGame}>Restart</button>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default React.memo(Game2048);"],"names":["getInitialGrid","grid","Array","fill","map","addRandomTile","emptyTiles","r","c","push","length","Math","floor","random","moveLeft","score","moved","row","filtered","filter","cell","i","splice","some","val","idx","rotateGrid","newGrid","SIZE","Game2048","setGrid","useState","setScore","topScore","setTopScore","gameOver","setGameOver","touchStart","setTouchStart","handleMove","direction","newScore","moveGrid","rightResult","upResult","downResult","leftResult","checkGameOver","handleKeyDown","e","key","startsWith","preventDefault","ArrowLeft","ArrowRight","ArrowUp","ArrowDown","useEffect","window","addEventListener","removeEventListener","_jsxs","className","onTouchStart","touch","touches","x","clientX","y","clientY","onTouchMove","onTouchEnd","changedTouches","dx","dy","abs","children","_jsx","rIdx","cIdx","concat","onClick","resetGame","React"],"sourceRoot":""}